# SoloDevFlow 2.0 - 产品PRD

> 为超级个体打造的自进化人机协作开发系统

---

## 一、产品愿景

### 一句话描述

**为超级个体提供从需求到部署的完整人机协作开发闭环的规范+工具。**

### 核心定位

这不仅是开发业务软件的工具，更是一个 **Self-Evolving Life Form**（自我进化的生命体）——由自己构建，随使用者习惯不断迭代的规范和工具。

### 三大特征

| 特征 | 说明 |
|------|------|
| **规范+工具** | 方法论引导 + 基础脚本辅助 / AI 遵循 Prompt 规范 |
| **自举** | 用自己来构建自己，吃自己的狗粮 |
| **元流程** | 通过结构化的 Meta-Flow 流程来手动持续优化规范 |

### 重要认知

**本系统是"引导"而非"强制"**：
- AI 行为依赖 CLAUDE.md 规范引导，而非技术手段强制
- AI 判断存在不一致性，需要在实践中逐步调优
- 规范的价值在于提供一致的协作框架，而非绝对的执行保证

### 人机职责分工

**核心原则：AI写，人审**

| 角色 | 职责 | 说明 |
|------|------|------|
| **人类** | 输入需求、审核、决策 | 提供散乱的想法和需求，审核AI产出，做最终决策 |
| **AI** | 结构化、编写、执行 | 将人类输入结构化归档到文档，编写代码，执行任务 |

**文档编写流程**：
```
人类口述需求/变更 → AI更新对应文档 → 人类审核确认 → AI执行实现
```

**为什么这样设计**：
- 让"文档即真理"可持续，不累死人
- AI擅长结构化和格式规范，人类擅长判断和决策
- 降低文档维护成本，提高执行一致性

---

## 二、目标用户

### 用户画像

```
名称：超级个体开发者

特征：
- 1个人完成产品全流程（需求→部署）
- 使用 Claude Code 作为AI协作伙伴
- 有开发经验，能看懂代码
- 追求效率，但不牺牲质量

痛点：
- 人类输入零散，注意力易分散
- AI不按流程执行，直接响应字面需求
- 变更影响感知差，改了A忘了B
- 状态管理混乱，无法掌控全局
```

---

## 三、核心架构元原则

> 这三条原则是整个系统的根基，所有设计和实现必须遵循。

### 元原则1：文档即真理源（Spec First）

**定义**：文档定义系统的行为契约，代码是契约的实现。

**文档类型**（按归属层级）：

| 归属 | 类型 | 描述 | 内容 | 必要性 |
|------|------|------|------|--------|
| 产品级 | 产品PRD | 产品是什么 | 愿景、用户、价值、元原则、路线图 | 必须 |
| 产品级 | 流程文档 | 如何协作 | 业务流程、模块依赖、协作顺序 | 必须 |
| 迭代级 | 迭代PRD | 迭代做什么 | 目标、范围、验收标准 | 必须 |
| 迭代级 | 模块文档 | 模块怎么做 | 业务概念、实体、规则、接口 | **可选** |

**模块文档可选规则**：
- 简单功能：直接在迭代PRD中描述，不需要单独模块文档
- 复杂模块：独立模块文档，当模块有复杂业务规则、多个接口、或需要跨迭代复用时
- 判断标准：如果迭代PRD中某功能描述超过1页，考虑拆分为模块文档

**变更规则**：

| 变更类型 | 产品PRD | 流程文档 | 迭代PRD | 模块文档 | 代码 |
|----------|---------|----------|---------|----------|------|
| 产品需求变更 | 先改 | 检查 | 检查 | 检查 | 后改 |
| 业务流程变更 | - | 先改 | 可能改 | 可能改 | 后改 |
| 迭代需求变更 | - | - | 可能改 | 可能改 | 后改 |
| 模块设计变更 | - | 检查 | 可能改 | 先改 | 后改 |
| 设计缺陷修复 | 检查 | 检查 | 检查 | 先改 | 后改 |
| Bug修复/重构 | - | - | - | - | 直接改 |

**设计缺陷修复**：在后续迭代中发现已完成模块的设计问题（接口/规则/逻辑），需先改文档再改代码。

**判断标准**：文档定义的内容变了吗？变了→先改对应层级文档。

**保障机制**：人类关注文档，AI管理代码，测试+验收保证一致性。

**Pending Docs 机制（一致性缓冲）**：

允许在编码实现过程中，暂时打破"先文档后代码"的规则，但在提交前必须还债。

**适用场景**：

| 场景 | 说明 | 示例 |
|------|------|------|
| **实现倒逼设计** | 编码时发现必须修改接口/数据结构才能跑通，原设计未覆盖 | "这个接口必须加 token 参数才能鉴权" |
| **快速热修复** | 通过对话直接修改代码细节，未先行修改文档 | "把默认值改成 10"、"文案改成 xxx" |

**流程**：
```
人类允许 AI 先改代码 → 记录变更到 .flow/pending-docs.md → 代码跑通
                                    ↓
                              Git Commit 前
                                    ↓
                  AI 根据 pending-docs 反向更新文档 → 清空
```

**规则**：
- 这是"借债"机制，不是逃避文档更新的借口
- 必须在当次 Commit 前清空，不允许跨 Commit 累积
- AI 在 Commit 前主动提醒："有 N 条 pending docs 待处理"

### 元原则2：三视图结构（分解+协作+能力）

**定义**：项目采用三种互补视图完整描述系统结构。

#### 视图A：树形分解（纵向）

**目的**：描述如何拆分为独立的功能单元

**结构**：
```
产品PRD（总）
  └── 迭代PRD（分/总）
        └── 模块设计（分）
```

**规则**：
- 最多3层：产品 → 迭代 → 模块
- 超过3层 → 拆分为独立产品
- 每层文档：先总后分

**文档**：产品PRD → 迭代PRD → 模块文档

#### 视图B：业务流程（横向协作）

**目的**：描述模块如何协作完成业务场景

**结构**：
```
【业务流程名称】
触发 → 模块A → 模块B → 模块C → 结果

模块依赖：
  模块A → 模块B（调用原因）
  模块A → 模块C（调用原因）
```

**内容**：
- 业务流程：协作顺序和触发条件
- 模块依赖：模块间的调用关系
- 模块职责：引用模块文档，不重复定义

**规则**：
- 核心业务流程必须显式描述
- 模块依赖关系必须记录
- 流程变更需先改流程文档，再改相关模块

**文档**：流程文档（业务流程部分）

#### 视图C：横向功能（跨模块能力）

**目的**：定义跨模块的公共能力和规范接口

**结构**：
```
【横向功能名称】（如：日志系统、状态管理）
  ├── 接口定义：标准接口规范
  ├── 调用规范：如何调用、何时调用
  └── 实现要求：可插拔、可替换
```

**内容**：
- 横向功能清单：日志、状态、验证等
- 接口规范：每个功能的标准接口
- 调用规范：模块如何使用横向功能

**规则**：
- 横向功能必须定义标准接口
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**文档**：流程文档（横向功能部分）或接口规范文档

### 元原则3：横向功能可插拔

**定义**：跨模块的横向功能，设计为可插拔的规范接口。

**规则**：
- 横向功能（日志、状态、验证等）定义标准接口规范
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**接口形态**：规范接口（文档定义），AI按规范实现。

**YAGNI 原则（迭代1适用）**：

对于 Solo 项目，遵循 "You Ain't Gonna Need It" 原则：
- 迭代1：横向功能用最简单方式实现（如日志直接用 console 封装一层）
- 迭代2+：根据实际替换需求再引入接口抽象
- 不要过早设计复杂的插件系统，除非真的有替换需求

**迭代说明**：此原则在迭代1中暂不深入实现，迭代2+根据实际需要逐步引入。

### 概念层级

```
元原则（Meta）          定义系统如何运作
  │
  ├── 业务流程（横向协作） 描述如何协作完成业务
  │     │
  │     └── 模块协作序列  触发 → 模块A → 模块B → 结果
  │
  ├── 横向功能（跨模块）  公共能力（日志、状态、验证...）
  │     │
  │     └── 规范接口      接口定义与调用规范
  │
  └── 纵向模块（独立）    业务功能单元
        │
        └── 模块实现      具体功能实现
```

**说明**：
- **业务流程**：连接多个模块，描述业务场景的执行流程
- **横向功能**：被多个模块使用，提供公共能力
- **纵向模块**：独立的业务功能，通过业务流程协作，通过横向功能获取公共能力

---

## 四、产品描述（High Level）

### 一、文档体系（元原则1：文档即真理源）

**定义**：文档是系统的真理源，代码是实现

```
【产品级文档】（项目启动阶段产出）
  ├── 产品PRD：定义产品愿景、用户、元原则、路线图
  └── 流程文档：定义业务流程、模块协作、横向功能接口

【迭代级文档】（每个迭代产出）
  ├── 迭代PRD：定义迭代目标、范围、验收标准
  └── 模块文档：定义模块概念、实体、规则、接口
```

**核心规范**：
- `CLAUDE.md`：AI协作规范（精简版，<100行），定义核心指令
- `docs/协作规范.md`：详细机制定义、阶段规则、文件格式规格

### 二、项目结构（元原则2：三视图）

#### 视图A：纵向模块（独立功能单元）

```
核心模块：
  ├── 输入捕获模块：识别并记录关键输入
  ├── 灵光收集箱：捕获与当前任务无关的想法
  ├── 影响分析工具：变更前分析影响范围（有局限性，见下文）
  └── 流程引导模块：判断输入与阶段的匹配度
```

#### 视图B：业务流程（模块协作）

```
【核心协作流程】
用户输入
  → AI判断类型（关键输入 / 灵光 / 执行指令）
  → 记录/执行（输入日志 / 灵光收集箱 / 执行任务）
  → 更新状态（流程上下文、分层状态）
  → 输出反馈（遵循输出规范）
```

#### 视图C：横向功能（跨模块能力）

```
公共能力：
  ├── 日志系统：输入日志、变更日志
  ├── 状态管理：流程上下文、state.json（唯一数据源，IDE中可折叠浏览）
  ├── 输出规范：总分结构、先全局后细节
  └── 验证机制：文档校验、流程校验（迭代2+引入校验脚本）
```

**影响分析工具的局限性**：

AI 分析变更影响范围存在已知局限：
- **隐式依赖难以发现**：反射、动态调用、配置注入等AI可能漏判
- **跨模块副作用**：修改A模块可能影响未直接依赖的C模块
- **置信度有限**：AI说"没问题"不代表真的没问题

**应对策略**：
- 不完全依赖AI的影响分析，配合测试验证
- 重要变更必须运行相关测试用例
- 迭代2+引入静态代码分析工具辅助

**状态管理说明**：

**唯一数据源**：`state.json`
- IDE 中节点可折叠，结构清晰
- 不维护额外的状态文件，避免同步负担
- `npm run status` 脚本可输出人类可读摘要

**跨 Session 状态连续性**：
- Claude Code 每次启动是全新上下文
- AI 必须在每次对话开始时主动读取 `.flow/state.json` 恢复状态
- CLAUDE.md 中明确定义此行为规范

**上下文加载策略**：

随着项目变大，不能把所有文档都塞给AI。定义以下加载规则：

| 场景 | 必须加载 | 按需加载 | 不加载 |
|------|----------|----------|--------|
| 任何场景 | state.json、CLAUDE.md | - | - |
| 修改模块A | 模块A文档、迭代PRD | 被A依赖的模块接口 | 其他模块文档 |
| 新功能设计 | 产品PRD、迭代PRD | 相关模块文档 | 已完成模块的实现细节 |
| Bug修复 | 相关代码文件 | 模块文档 | 产品PRD |

**加载优先级**：状态 > 当前任务相关 > 依赖项 > 其他

**AI 主动索取上下文**：

为减轻人类"投喂文档"的负担，AI 应主动索取所需上下文：

```
【AI 行为规范】
当准备修改某个模块的代码时：
1. 先检查是否已了解该模块的设计文档
2. 如果没有，主动询问："我需要先了解 [模块名] 的设计文档，请问是否需要我读取 docs/modules/xxx.md？"
3. 人类确认后再读取并开始工作

当准备进入新的迭代/阶段时：
1. 主动询问是否需要加载相关的迭代PRD
2. 不要等人类想起来才投喂
```

**核心原则**：变"人主动投喂"为"AI主动索取"

### AI 判断规则（边界定义）

为提高 AI 判断一致性，定义以下分类规则：

**关键输入 vs 普通对话**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 关键输入 | 影响产品方向、设计决策、功能定义 | "登录要支持微信"、"先做A再做B"、"这个方案不行" |
| 普通对话 | 确认、闲聊、操作指令 | "好的"、"继续"、"帮我看看这个文件" |

**灵光 vs 当前任务延伸**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 灵光 | 与当前迭代/任务无直接关联 | 正在做登录，突然说"以后要加支付" |
| 任务延伸 | 当前任务的细化、补充、调整 | 正在做登录，说"登录后要跳转到首页" |

**符合阶段 vs 不符合阶段**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 符合 | 请求属于当前阶段的正常产出 | 需求阶段讨论功能范围 |
| 不符合 | 请求属于其他阶段的产出 | 需求阶段要求写代码 |

### 三、规范体系（产出物规范）

> 定义各类产出物"怎么写"的规范，AI按规范执行，人类按规范审核

**规范清单**：

| 规范 | 用途 | 负责角色 | 加载时机 |
|------|------|----------|----------|
| **需求文档规范** | 定义迭代PRD的结构、内容要素、编写标准 | 产品 | 需求阶段 |
| **设计文档规范** | 定义技术设计的结构、内容要素、编写标准 | 架构/研发 | 设计阶段 |
| **研发规范** | 定义代码结构、代码风格、单元测试、集成测试 | 研发工程师 | 实现阶段 |
| **测试规范** | 定义E2E测试、性能测试、破坏性测试、健壮测试 | 测试工程师 | 验证阶段 |

**规范特点**：
- **按需加载**：AI根据当前阶段/任务加载对应规范，减少上下文噪音
- **自举产出**：规范本身通过SoloDevFlow流程开发（需求→设计→实现）
- **渐进完善**：迭代1建立基础版本，后续迭代根据实践反馈优化

**与协作规范的关系**：
- `协作规范.md`：定义人机协作流程（"何时做"、"怎么协作"）
- `产出物规范`：定义各类文档/代码的编写标准（"怎么写"）

### 四、系统能力

```
【规范层】（迭代1）
  └── CLAUDE.md（精简版） + 协作规范.md（详细版） + 产品PRD
      定义：流程阶段、AI行为准则、协作模式

【工具层-基础】（迭代1）
  └── 基础 npm scripts
      - status.js：状态摘要查看
      - validate.js：格式校验

【工具层-增强】（迭代2+）
  └── 增强工具
      - Git hooks 集成
      - 自动影响分析
      - 文档一致性检查

【进化层】（迭代3+）
  └── 元流程优化
      支持：规范版本管理、使用者偏好记录、自适应调整
```

### 四、核心流程

> **注意**：本章定义的是**目标架构**，描述系统完整形态。
> 各机制的迭代归属见"六、路线图 → 核心流程机制实现路线"。
> 迭代1采用简化/手动版本实现。

#### 4.1 整体流程

```
项目启动 → 迭代循环（需求 ←→ 设计 ←→ 实现 → 验证）
                         ↑__________↑__________↑
                              (可回退)
```

#### 4.2 迭代内阶段流转

**正常流转**：需求 → 设计 → 实现 → 验证 → 迭代完成

**阶段定义**：

| 阶段 | 核心活动 | 产出物 |
|------|----------|--------|
| **需求** | 分析需求、定义范围、明确验收标准 | 迭代PRD |
| **设计** | 模块拆分、接口定义、技术方案 | 模块文档（可选） |
| **实现** | 编码、单元测试 | 代码 |
| **验证** | 集成测试、验收测试 | 测试报告 |

**回退规则**（发现问题时可回退到早期阶段）：

| 当前阶段 | 回退到 | 触发条件 | 必须做的事 |
|----------|--------|----------|------------|
| 设计 | 需求 | 需求不完整/矛盾 | 更新迭代PRD，重新进入设计 |
| 实现 | 设计 | 设计不可行 | 更新模块文档，重新进入实现 |
| 实现 | 需求 | 需求理解偏差 | 更新迭代PRD，重新走设计→实现 |
| 验证 | 设计 | 发现设计缺陷 | 更新模块文档，修复后重新验证 |
| 验证 | 需求 | 需求定义错误 | 更新迭代PRD，重新走完整流程 |

**回退时必须**：
1. 记录回退原因到输入日志
2. 更新受影响模块的状态
3. 标记待重做的产出物

#### 4.3 模块级状态

**核心思想**：迭代内各模块可以处于不同阶段

```json
{
  "iteration": {
    "id": 1,
    "phase": "implementation",
    "modules": {
      "模块A": { "phase": "design", "status": "blocked", "blocker": "需求不完整" },
      "模块B": { "phase": "implementation", "status": "in_progress" },
      "模块C": { "phase": "verification", "status": "completed" }
    }
  }
}
```

**规则**：
- 迭代整体阶段 = 所有模块中最早的阶段
- 单个模块可独立回退，不影响其他模块
- 迭代完成 = 所有模块都验证通过

#### 4.4 变更处理流程

**变更类型**：

| 类型 | 触发条件 | 影响范围 | 处理方式 |
|------|----------|----------|----------|
| **产品级** | 元原则/愿景/路线图变更 | 可能影响多个迭代 | 暂停当前迭代，先处理产品PRD |
| **迭代级** | 迭代目标/范围变更 | 当前迭代所有模块 | 更新迭代PRD，重新评估模块状态 |
| **模块级** | 模块设计/接口变更 | 单个或相关模块 | 更新模块文档，该模块可能回退 |

**变更传播流程**：

```
1. 识别变更
   ↓
2. 影响分析（AI生成影响清单）
   ├─ 文档影响：哪些文档需要改
   ├─ 代码影响：哪些代码需要改
   └─ 依赖影响：哪些模块被间接影响
   ↓
3. 人类审批影响清单
   ├─ 确认：继续处理
   ├─ 调整：修改影响范围
   └─ 拒绝：取消变更
   ↓
4. 挂起当前任务（压入任务栈）
   ↓
5. 按优先级处理影响项
   ├─ 优先级：文档 → 设计 → 代码
   ├─ 分批处理（影响项 > 3 个时）
   └─ 每批完成后人类确认
   ↓
6. 全部完成 → 弹出任务栈 → 恢复原任务
```

#### 4.5 任务栈机制

**解决问题**：AI处理变更后忘记原任务

**结构**（`.flow/task-stack.json`）：

```json
{
  "stack": [
    {
      "id": "task-001",
      "type": "implementation",
      "target": "模块A",
      "status": "suspended",
      "reason": "触发变更处理",
      "suspendedAt": "2024-12-17T10:00:00Z"
    },
    {
      "id": "task-002",
      "type": "change_propagation",
      "trigger": "产品PRD变更",
      "status": "in_progress",
      "affectedItems": ["迭代PRD", "模块A文档", "模块B文档"],
      "completedItems": ["迭代PRD"],
      "currentItem": "模块A文档"
    }
  ]
}
```

**规则**：
- 原任务挂起（suspended），不是丢弃
- 变更处理完成后，自动弹出栈顶，恢复原任务
- Session 断开后，AI 读取任务栈恢复上下文
- 栈深度限制：最多 3 层（防止无限嵌套）

#### 4.6 分批处理规则

**触发条件**：影响项 > 3 个

**处理方式**：

| 批次 | 内容 | 完成后 |
|------|------|--------|
| 第一批 | 核心文档（产品PRD/迭代PRD） | 人类确认 |
| 第二批 | 模块文档（每次最多2个） | 人类确认 |
| 第三批 | 代码变更（按模块逐个） | 运行测试 |

**每批之间**：
- 更新任务栈状态
- 人类可选择继续/暂停/终止

#### 4.7 异常场景处理

| 场景 | 处理方式 |
|------|----------|
| Session 断开 | AI 重启后读取 task-stack.json，恢复到断点 |
| 变更处理中又有新变更 | 压入新任务到栈顶，优先处理（栈深度 < 3） |
| 栈深度达到上限 | 拒绝新变更，提示人类先完成当前变更 |
| 影响分析遗漏 | 后续发现时补充到任务栈，继续处理 |
| 人类取消变更 | 弹出变更任务，恢复原任务，标记变更为已取消 |

---

## 五、项目启动阶段产出

**产品级文档（项目启动阶段产出）**：

| 文档 | 目的 | 内容 |
|------|------|------|
| **产品PRD** | 定义产品是什么 | 愿景、用户、元原则、路线图 |
| **流程文档** | 定义如何协作 | 业务流程（High Level）、协作模式、模块职责划分 |

**创建时机**：
- 产品PRD定稿后，同步创建流程文档
- 流程文档定义 High Level 的业务流程和协作模式
- 后续迭代基于流程文档进行细化和修订

**为什么在项目启动阶段创建流程文档**：
1. 符合"文档即真理源"原则 - 产品级文档在产品级阶段产出
2. 先定义协作方式，再细化实现 - 指导后续迭代设计
3. 避免"实现驱动设计" - 确保各迭代设计符合整体协作视角

---

## 六、路线图

### 阶段划分

| 阶段 | 目标 | 状态 |
|------|------|------|
| **迭代1** | 核心流程可用 | → 当前 |
| **迭代2** | 工具化增强 (CLI/Scripts) | 待规划 |
| **迭代3** | 知识库与元流程优化 | 待规划 |

### 元原则实现路线

| 元原则 | 迭代1 | 迭代2 | 迭代3 |
|--------|-------|-------|-------|
| **1. 文档即真理源** | Pending Docs机制、状态管理、输入日志 | 文档校验工具、自动一致性检查 | - |
| **2. 三视图结构** | CLAUDE.md暂代流程文档（裁剪） | 独立流程文档、模块依赖图 | 可视化依赖关系 |
| **3. 横向功能可插拔** | 最简实现（YAGNI原则） | 标准接口规范定义 | 可替换实现、插件机制 |

### 核心流程机制实现路线

| 机制 | 迭代1 | 迭代2 | 迭代3 |
|------|-------|-------|-------|
| **阶段回退** | 手动回退（AI引导） | 脚本辅助回退 | - |
| **模块级状态** | 简化版（迭代级状态） | 完整模块级状态 | - |
| **任务栈机制** | 无（单任务模式） | 完整任务栈 | - |
| **变更传播** | 手动影响分析 | 自动影响分析工具 | - |
| **分批处理** | 无（手动控制） | 自动分批 | - |
| **异常处理** | 人工判断 | 工具辅助恢复 | - |
| **历史归档** | 无（手动管理） | history/ 自动归档 | - |

**说明**：
- 迭代1聚焦"跑通流程"，复杂机制采用手动/简化版
- 第四章定义的完整机制是**目标架构**，迭代1用最简方式实现
- 迭代2+根据实际痛点逐步工具化

### 迭代1目标

**迭代1 是"规范从0到1"的迭代**，核心定位是建立基线，而非完美执行。

**交付物**：
- 规范文档：CLAUDE.md（精简版，<100行） + 协作规范.md（详细版）
- 模板文件：.flow/ 目录结构和初始模板
- 基础脚本：status.js + validate.js（2个辅助脚本）

**诚实的预期**：

| 承诺 | 不承诺 |
|------|--------|
| 规范文档完整可读 | AI 100%按规范执行 |
| 模板文件格式正确 | AI 判断永远准确 |
| 脚本可运行无报错 | 流程完美无缺陷 |

**为什么这样定位**：
- AI 行为依赖 Prompt 引导，不是代码强制
- 规范的一致性需要迭代2的校验工具来保障
- 迭代1 的价值是"建立基线"，迭代2 才是"强化执行"

**迭代1不包含**（目标架构，迭代2+实现）：
- AI行为一致性保证（需要工具强制）
- 任务栈机制（迭代1为单任务模式）
- 自动变更传播（迭代1为手动影响分析）
- 模块级状态（迭代1为迭代级状态）

详见：[迭代1-PRD](./iterations/迭代1-PRD.md)

---

## 七、成功标准

### 迭代1成功标准

**文档验收**：
- [ ] CLAUDE.md 精简版 <100行，包含核心指令
- [ ] 协作规范.md 包含所有核心机制定义（输入日志、灵光收集箱、流程上下文、影响分析、状态管理、Pending Docs）
- [ ] 产品PRD 结构完整（愿景、元原则、路线图）
- [ ] 迭代1-PRD 规格清晰（交付物、格式规格、验收标准）

**模板验收**：
- [ ] .flow/ 目录结构正确
- [ ] state.json 格式符合规格
- [ ] input-log.md / spark-box.md / pending-docs.md 模板格式正确

**脚本验收**：
- [ ] `npm run status` 可运行，输出符合规格
- [ ] `npm run validate` 可运行，能检测格式错误

**自举实验**：
- [ ] 用迭代1流程完成迭代1开发
- [ ] 记录过程中发现的问题（不要求零问题）
- [ ] 产出 `.flow/自举实验记录.md`

### 产品最终成功标准

- [ ] 超级个体能独立使用完成软件开发全流程
- [ ] 流程规范能随使用者显式配置进化
- [ ] 工具能辅助规范执行（迭代2+逐步强化）
- [ ] AI 行为一致性持续提升（通过实践反馈优化 CLAUDE.md）

---

*版本：v1.3*
*创建时间：2024-12-16*
*更新时间：2024-12-20*
*更新内容：v0.2 增加重要认知、AI判断规则；v0.3 增加人机职责分工、上下文加载策略、Pending Docs机制、影响分析局限性、YAGNI原则、模块文档可选；v0.4 简化迭代1状态管理为仅 state.json、AI主动索取上下文；v0.5 重新定义 Pending Docs 触发场景（实现倒逼设计、快速热修复）；v0.6 重构核心流程：增加阶段回退规则、模块级状态、变更传播流程、任务栈机制、分批处理规则、异常场景处理；v0.7 明确核心流程机制的迭代归属，区分目标架构与迭代1实现；v0.8 补充历史归档机制的迭代归属（迭代2）；v0.9 同步迭代1-PRD v2.0重构：更新迭代1目标定位（规范定义迭代）、成功标准（去掉主观量化指标）、系统能力（迭代1包含基础脚本）；v1.0 移除 status.md，state.json 为唯一状态源；v1.1 CLAUDE.md 拆分为精简版+详细版（协作规范.md），遵循业界最佳实践；v1.2 新增规范体系（产出物规范）需求声明；v1.3 规范体系调整为4个（需求文档/设计文档/研发/测试），区分研发工程师和测试工程师职责*
