# SoloDevFlow 2.0 - 产品PRD

> 为超级个体打造的自进化人机协作开发系统

---

## 一、产品愿景

### 一句话描述

**为超级个体提供从需求到部署的完整人机协作开发闭环的规范+工具。**

### 核心定位

这不仅是开发业务软件的工具，更是一个 **Self-Evolving Life Form**（自我进化的生命体）——由自己构建，随使用者习惯不断迭代的规范和工具。

### 三大特征

| 特征 | 说明 |
|------|------|
| **规范+工具** | 方法论指导 + 基础脚本辅助 / AI 严格遵循 Prompt |
| **自举** | 用自己来构建自己，吃自己的狗粮 |
| **元流程** | 通过结构化的 Meta-Flow 流程来手动持续优化规范 |

---

## 二、目标用户

### 用户画像

```
名称：超级个体开发者

特征：
- 1个人完成产品全流程（需求→部署）
- 使用 Claude Code 作为AI协作伙伴
- 有开发经验，能看懂代码
- 追求效率，但不牺牲质量

痛点：
- 人类输入零散，注意力易分散
- AI不按流程执行，直接响应字面需求
- 变更影响感知差，改了A忘了B
- 状态管理混乱，无法掌控全局
```

---

## 三、核心架构元原则

> 这三条原则是整个系统的根基，所有设计和实现必须遵循。

### 元原则1：文档即真理源（Spec First）

**定义**：文档定义系统的行为契约，代码是契约的实现。

**文档类型**（按归属层级）：

| 归属 | 类型 | 描述 | 内容 |
|------|------|------|------|
| 产品级 | 产品PRD | 产品是什么 | 愿景、用户、价值、元原则、路线图 |
| 产品级 | 流程文档 | 如何协作 | 业务流程、模块依赖、协作顺序（职责引用模块文档） |
| 迭代级 | 迭代PRD | 迭代做什么 | 目标、范围、验收标准 |
| 迭代级 | 模块文档 | 模块怎么做 | 业务概念、实体、规则、接口、验收标准 |

**变更规则**：

| 变更类型 | 产品PRD | 流程文档 | 迭代PRD | 模块文档 | 代码 |
|----------|---------|----------|---------|----------|------|
| 产品需求变更 | 先改 | 检查 | 检查 | 检查 | 后改 |
| 业务流程变更 | - | 先改 | 可能改 | 可能改 | 后改 |
| 迭代需求变更 | - | - | 可能改 | 可能改 | 后改 |
| 模块设计变更 | - | 检查 | 可能改 | 先改 | 后改 |
| 设计缺陷修复 | 检查 | 检查 | 检查 | 先改 | 后改 |
| Bug修复/重构 | - | - | - | - | 直接改 |

**设计缺陷修复**：在后续迭代中发现已完成模块的设计问题（接口/规则/逻辑），需先改文档再改代码。

**判断标准**：文档定义的内容变了吗？变了→先改对应层级文档。

**保障机制**：人类关注文档，AI管理代码，测试+验收保证一致性。

### 元原则2：三视图结构（分解+协作+能力）

**定义**：项目采用三种互补视图完整描述系统结构。

#### 视图A：树形分解（纵向）

**目的**：描述如何拆分为独立的功能单元

**结构**：
```
产品PRD（总）
  └── 迭代PRD（分/总）
        └── 模块设计（分）
```

**规则**：
- 最多3层：产品 → 迭代 → 模块
- 超过3层 → 拆分为独立产品
- 每层文档：先总后分

**文档**：产品PRD → 迭代PRD → 模块文档

#### 视图B：业务流程（横向协作）

**目的**：描述模块如何协作完成业务场景

**结构**：
```
【业务流程名称】
触发 → 模块A → 模块B → 模块C → 结果

模块依赖：
  模块A → 模块B（调用原因）
  模块A → 模块C（调用原因）
```

**内容**：
- 业务流程：协作顺序和触发条件
- 模块依赖：模块间的调用关系
- 模块职责：引用模块文档，不重复定义

**规则**：
- 核心业务流程必须显式描述
- 模块依赖关系必须记录
- 流程变更需先改流程文档，再改相关模块

**文档**：流程文档（业务流程部分）

#### 视图C：横向功能（跨模块能力）

**目的**：定义跨模块的公共能力和规范接口

**结构**：
```
【横向功能名称】（如：日志系统、状态管理）
  ├── 接口定义：标准接口规范
  ├── 调用规范：如何调用、何时调用
  └── 实现要求：可插拔、可替换
```

**内容**：
- 横向功能清单：日志、状态、验证等
- 接口规范：每个功能的标准接口
- 调用规范：模块如何使用横向功能

**规则**：
- 横向功能必须定义标准接口
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**文档**：流程文档（横向功能部分）或接口规范文档

### 元原则3：横向功能可插拔

**定义**：跨模块的横向功能，设计为可插拔的规范接口。

**规则**：
- 横向功能（日志、状态、验证等）定义标准接口规范
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**接口形态**：规范接口（文档定义），AI按规范实现。

### 概念层级

```
元原则（Meta）          定义系统如何运作
  │
  ├── 业务流程（横向协作） 描述如何协作完成业务
  │     │
  │     └── 模块协作序列  触发 → 模块A → 模块B → 结果
  │
  ├── 横向功能（跨模块）  公共能力（日志、状态、验证...）
  │     │
  │     └── 规范接口      接口定义与调用规范
  │
  └── 纵向模块（独立）    业务功能单元
        │
        └── 模块实现      具体功能实现
```

**说明**：
- **业务流程**：连接多个模块，描述业务场景的执行流程
- **横向功能**：被多个模块使用，提供公共能力
- **纵向模块**：独立的业务功能，通过业务流程协作，通过横向功能获取公共能力

---

## 四、产品描述（High Level）

### 核心组成

```
┌─────────────────────────────────────────────────────────────────┐
│                      SoloDevFlow 2.0                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【规范层】                                                     │
│     CLAUDE.md - 核心流程规范                                     │
│     定义：阶段、机制、AI行为准则                                  │
│                                                                 │
│   【工具层】                                                     │
│     流程状态管理 - 知道在哪、做什么                               │
│     输入捕获工具 - 不丢失人类输入                                 │
│     影响分析工具 - 变更前看全局                                   │
│     校验工具 - 强制规范执行                                      │
│                                                                 │
│   【进化层】                                                     │
│     规范版本管理 - 记录每次调整                                   │
│     习惯学习 - 记录使用者偏好                                    │
│     自适应 - 应用到后续流程                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 核心流程

```
项目启动 → 迭代循环（规划 → 设计 → 实现 → 验证）
```

### 核心机制

| 机制 | 作用 |
|------|------|
| **输入日志** | 捕获人类所有关键输入 |
| **灵光收集箱** | 记录灵光一闪，不打断流程 |
| **流程上下文** | AI始终知道当前阶段 |
| **影响分析** | 变更前分析影响范围 |
| **分层状态** | 人类可读 + AI可用 |
| **输出规范** | 总分结构，先全局后细节 |

---

## 五、项目启动阶段产出

**产品级文档（项目启动阶段产出）**：

| 文档 | 目的 | 内容 |
|------|------|------|
| **产品PRD** | 定义产品是什么 | 愿景、用户、元原则、路线图 |
| **流程文档** | 定义如何协作 | 业务流程（High Level）、协作模式、模块职责划分 |

**创建时机**：
- 产品PRD定稿后，同步创建流程文档
- 流程文档定义 High Level 的业务流程和协作模式
- 后续迭代基于流程文档进行细化和修订

**为什么在项目启动阶段创建流程文档**：
1. 符合"文档即真理源"原则 - 产品级文档在产品级阶段产出
2. 先定义协作方式，再细化实现 - 指导后续迭代设计
3. 避免"实现驱动设计" - 确保各迭代设计符合整体协作视角

---

## 六、路线图

### 阶段划分

| 阶段 | 目标 | 状态 |
|------|------|------|
| **迭代1** | 核心流程可用 | → 当前 |
| **迭代2** | 工具化增强 (CLI/Scripts) | 待规划 |
| **迭代3** | 知识库与元流程优化 | 待规划 |

### 迭代1目标

让核心流程**手动可用**：
- 输入日志机制
- 灵光收集箱
- 流程上下文
- 分层状态

详见：[迭代1-PRD](./iterations/迭代1-PRD.md)

---

## 七、成功标准

### 迭代1成功标准

- [ ] 能用此流程完成一个完整迭代
- [ ] 人类输入不丢失
- [ ] AI能按流程引导，不直接响应字面需求
- [ ] 状态可读、可追溯

### 产品最终成功标准

- [ ] 超级个体能独立使用完成软件开发全流程
- [ ] 流程规范能随使用者显式配置进化
- [ ] 工具能辅助规范执行

---

*版本：v0.1*
*创建时间：2024-12-16*
