# SoloDevFlow 2.0 - 产品PRD

> 为超级个体打造的自进化人机协作开发系统

---

## 一、产品愿景

### 一句话描述

**为超级个体提供从需求到部署的完整人机协作开发闭环的规范+工具。**

### 核心定位

这不仅是开发业务软件的工具，更是一个 **Self-Evolving Life Form**（自我进化的生命体）——由自己构建，随使用者习惯不断迭代的规范和工具。

### 三大特征

| 特征 | 说明 |
|------|------|
| **规范+工具** | 方法论引导 + 基础脚本辅助 / AI 遵循 Prompt 规范 |
| **自举** | 用自己来构建自己，吃自己的狗粮 |
| **元流程** | 通过结构化的 Meta-Flow 流程来手动持续优化规范 |

### 重要认知

**本系统是"引导"而非"强制"**：
- AI 行为依赖 CLAUDE.md 规范引导，而非技术手段强制
- AI 判断存在不一致性，需要在实践中逐步调优
- 规范的价值在于提供一致的协作框架，而非绝对的执行保证

### 人机职责分工

**核心原则：AI写，人审**

| 角色 | 职责 | 说明 |
|------|------|------|
| **人类** | 输入需求、审核、决策 | 提供散乱的想法和需求，审核AI产出，做最终决策 |
| **AI** | 结构化、编写、执行 | 将人类输入结构化归档到文档，编写代码，执行任务 |

**文档编写流程**：
```
人类口述需求/变更 → AI更新对应文档 → 人类审核确认 → AI执行实现
```

**为什么这样设计**：
- 让"文档即真理"可持续，不累死人
- AI擅长结构化和格式规范，人类擅长判断和决策
- 降低文档维护成本，提高执行一致性

---

## 二、目标用户

### 用户画像

```
名称：超级个体开发者

特征：
- 1个人完成产品全流程（需求→部署）
- 使用 Claude Code 作为AI协作伙伴
- 有开发经验，能看懂代码
- 追求效率，但不牺牲质量

痛点：
- 人类输入零散，注意力易分散
- AI不按流程执行，直接响应字面需求
- 变更影响感知差，改了A忘了B
- 状态管理混乱，无法掌控全局
```

---

## 三、核心架构元原则

> 这三条原则是整个系统的根基，所有设计和实现必须遵循。

### 元原则1：文档即真理源（Spec First）

**定义**：文档定义系统的行为契约，代码是契约的实现。

**文档类型**（按归属层级）：

| 归属 | 类型 | 描述 | 内容 | 必要性 |
|------|------|------|------|--------|
| 产品级 | 产品PRD | 产品是什么 | 愿景、用户、价值、元原则、路线图 | 必须 |
| 产品级 | 流程文档 | 如何协作 | 业务流程、模块依赖、协作顺序 | 必须 |
| 迭代级 | 迭代PRD | 迭代做什么 | 目标、范围、验收标准 | 必须 |
| 迭代级 | 模块文档 | 模块怎么做 | 业务概念、实体、规则、接口 | **可选** |

**模块文档可选规则**：
- 简单功能：直接在迭代PRD中描述，不需要单独模块文档
- 复杂模块：独立模块文档，当模块有复杂业务规则、多个接口、或需要跨迭代复用时
- 判断标准：如果迭代PRD中某功能描述超过1页，考虑拆分为模块文档

**变更规则**：

| 变更类型 | 产品PRD | 流程文档 | 迭代PRD | 模块文档 | 代码 |
|----------|---------|----------|---------|----------|------|
| 产品需求变更 | 先改 | 检查 | 检查 | 检查 | 后改 |
| 业务流程变更 | - | 先改 | 可能改 | 可能改 | 后改 |
| 迭代需求变更 | - | - | 可能改 | 可能改 | 后改 |
| 模块设计变更 | - | 检查 | 可能改 | 先改 | 后改 |
| 设计缺陷修复 | 检查 | 检查 | 检查 | 先改 | 后改 |
| Bug修复/重构 | - | - | - | - | 直接改 |

**设计缺陷修复**：在后续迭代中发现已完成模块的设计问题（接口/规则/逻辑），需先改文档再改代码。

**判断标准**：文档定义的内容变了吗？变了→先改对应层级文档。

**保障机制**：人类关注文档，AI管理代码，测试+验收保证一致性。

**Pending Docs 机制（一致性缓冲）**：

允许在编码实现过程中，暂时打破"先文档后代码"的规则，但在提交前必须还债。

**适用场景**：

| 场景 | 说明 | 示例 |
|------|------|------|
| **实现倒逼设计** | 编码时发现必须修改接口/数据结构才能跑通，原设计未覆盖 | "这个接口必须加 token 参数才能鉴权" |
| **快速热修复** | 通过对话直接修改代码细节，未先行修改文档 | "把默认值改成 10"、"文案改成 xxx" |

**流程**：
```
人类允许 AI 先改代码 → 记录变更到 .flow/pending-docs.md → 代码跑通
                                    ↓
                              Git Commit 前
                                    ↓
                  AI 根据 pending-docs 反向更新文档 → 清空
```

**规则**：
- 这是"借债"机制，不是逃避文档更新的借口
- 必须在当次 Commit 前清空，不允许跨 Commit 累积
- AI 在 Commit 前主动提醒："有 N 条 pending docs 待处理"

### 元原则2：三视图结构（分解+协作+能力）

**定义**：项目采用三种互补视图完整描述系统结构。

#### 视图A：树形分解（纵向）

**目的**：描述如何拆分为独立的功能单元

**结构**：
```
产品PRD（总）
  └── 迭代PRD（分/总）
        └── 模块设计（分）
```

**规则**：
- 最多3层：产品 → 迭代 → 模块
- 超过3层 → 拆分为独立产品
- 每层文档：先总后分

**文档**：产品PRD → 迭代PRD → 模块文档

#### 视图B：业务流程（横向协作）

**目的**：描述模块如何协作完成业务场景

**结构**：
```
【业务流程名称】
触发 → 模块A → 模块B → 模块C → 结果

模块依赖：
  模块A → 模块B（调用原因）
  模块A → 模块C（调用原因）
```

**内容**：
- 业务流程：协作顺序和触发条件
- 模块依赖：模块间的调用关系
- 模块职责：引用模块文档，不重复定义

**规则**：
- 核心业务流程必须显式描述
- 模块依赖关系必须记录
- 流程变更需先改流程文档，再改相关模块

**文档**：流程文档（业务流程部分）

#### 视图C：横向功能（跨模块能力）

**目的**：定义跨模块的公共能力和规范接口

**结构**：
```
【横向功能名称】（如：日志系统、状态管理）
  ├── 接口定义：标准接口规范
  ├── 调用规范：如何调用、何时调用
  └── 实现要求：可插拔、可替换
```

**内容**：
- 横向功能清单：日志、状态、验证等
- 接口规范：每个功能的标准接口
- 调用规范：模块如何使用横向功能

**规则**：
- 横向功能必须定义标准接口
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**文档**：流程文档（横向功能部分）或接口规范文档

### 元原则3：横向功能可插拔

**定义**：跨模块的横向功能，设计为可插拔的规范接口。

**规则**：
- 横向功能（日志、状态、验证等）定义标准接口规范
- 纵向模块通过接口调用，不依赖具体实现
- 接口可独立替换、升级、禁用

**接口形态**：规范接口（文档定义），AI按规范实现。

**YAGNI 原则（迭代1适用）**：

对于 Solo 项目，遵循 "You Ain't Gonna Need It" 原则：
- 迭代1：横向功能用最简单方式实现（如日志直接用 console 封装一层）
- 迭代2+：根据实际替换需求再引入接口抽象
- 不要过早设计复杂的插件系统，除非真的有替换需求

**迭代说明**：此原则在迭代1中暂不深入实现，迭代2+根据实际需要逐步引入。

### 概念层级

```
元原则（Meta）          定义系统如何运作
  │
  ├── 业务流程（横向协作） 描述如何协作完成业务
  │     │
  │     └── 模块协作序列  触发 → 模块A → 模块B → 结果
  │
  ├── 横向功能（跨模块）  公共能力（日志、状态、验证...）
  │     │
  │     └── 规范接口      接口定义与调用规范
  │
  └── 纵向模块（独立）    业务功能单元
        │
        └── 模块实现      具体功能实现
```

**说明**：
- **业务流程**：连接多个模块，描述业务场景的执行流程
- **横向功能**：被多个模块使用，提供公共能力
- **纵向模块**：独立的业务功能，通过业务流程协作，通过横向功能获取公共能力

---

## 四、产品描述（High Level）

### 一、文档体系（元原则1：文档即真理源）

**定义**：文档是系统的真理源，代码是实现

```
【产品级文档】（项目启动阶段产出）
  ├── 产品PRD：定义产品愿景、用户、元原则、路线图
  └── 流程文档：定义业务流程、模块协作、横向功能接口

【迭代级文档】（每个迭代产出）
  ├── 迭代PRD：定义迭代目标、范围、验收标准
  └── 模块文档：定义模块概念、实体、规则、接口
```

**核心规范**：
- `CLAUDE.md`：AI协作规范，定义阶段、机制、行为准则

### 二、项目结构（元原则2：三视图）

#### 视图A：纵向模块（独立功能单元）

```
核心模块：
  ├── 输入捕获模块：识别并记录关键输入
  ├── 灵光收集箱：捕获与当前任务无关的想法
  ├── 影响分析工具：变更前分析影响范围（有局限性，见下文）
  └── 流程引导模块：判断输入与阶段的匹配度
```

#### 视图B：业务流程（模块协作）

```
【核心协作流程】
用户输入
  → AI判断类型（关键输入 / 灵光 / 执行指令）
  → 记录/执行（输入日志 / 灵光收集箱 / 执行任务）
  → 更新状态（流程上下文、分层状态）
  → 输出反馈（遵循输出规范）
```

#### 视图C：横向功能（跨模块能力）

```
公共能力：
  ├── 日志系统：输入日志、变更日志
  ├── 状态管理：流程上下文、分层状态（state.json 为唯一数据源，status.md 为其可读视图）
  ├── 输出规范：总分结构、先全局后细节
  └── 验证机制：文档校验、流程校验（迭代2+引入校验脚本）
```

**影响分析工具的局限性**：

AI 分析变更影响范围存在已知局限：
- **隐式依赖难以发现**：反射、动态调用、配置注入等AI可能漏判
- **跨模块副作用**：修改A模块可能影响未直接依赖的C模块
- **置信度有限**：AI说"没问题"不代表真的没问题

**应对策略**：
- 不完全依赖AI的影响分析，配合测试验证
- 重要变更必须运行相关测试用例
- 迭代2+引入静态代码分析工具辅助

**状态管理说明**：

迭代1（手动模式）：
- 只使用 `state.json`，IDE 中节点可折叠，结构清晰
- 不引入 `status.md`，避免双文件同步负担

迭代2+（有脚本后）：
- `state.json` 保持为唯一数据源
- 可选：脚本自动生成 `status.md` 供快速浏览

**跨 Session 状态连续性**：
- Claude Code 每次启动是全新上下文
- AI 必须在每次对话开始时主动读取 `.flow/state.json` 恢复状态
- CLAUDE.md 中明确定义此行为规范

**上下文加载策略**：

随着项目变大，不能把所有文档都塞给AI。定义以下加载规则：

| 场景 | 必须加载 | 按需加载 | 不加载 |
|------|----------|----------|--------|
| 任何场景 | state.json、CLAUDE.md | - | - |
| 修改模块A | 模块A文档、迭代PRD | 被A依赖的模块接口 | 其他模块文档 |
| 新功能设计 | 产品PRD、迭代PRD | 相关模块文档 | 已完成模块的实现细节 |
| Bug修复 | 相关代码文件 | 模块文档 | 产品PRD |

**加载优先级**：状态 > 当前任务相关 > 依赖项 > 其他

**AI 主动索取上下文**：

为减轻人类"投喂文档"的负担，AI 应主动索取所需上下文：

```
【AI 行为规范】
当准备修改某个模块的代码时：
1. 先检查是否已了解该模块的设计文档
2. 如果没有，主动询问："我需要先了解 [模块名] 的设计文档，请问是否需要我读取 docs/modules/xxx.md？"
3. 人类确认后再读取并开始工作

当准备进入新的迭代/阶段时：
1. 主动询问是否需要加载相关的迭代PRD
2. 不要等人类想起来才投喂
```

**核心原则**：变"人主动投喂"为"AI主动索取"

### AI 判断规则（边界定义）

为提高 AI 判断一致性，定义以下分类规则：

**关键输入 vs 普通对话**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 关键输入 | 影响产品方向、设计决策、功能定义 | "登录要支持微信"、"先做A再做B"、"这个方案不行" |
| 普通对话 | 确认、闲聊、操作指令 | "好的"、"继续"、"帮我看看这个文件" |

**灵光 vs 当前任务延伸**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 灵光 | 与当前迭代/任务无直接关联 | 正在做登录，突然说"以后要加支付" |
| 任务延伸 | 当前任务的细化、补充、调整 | 正在做登录，说"登录后要跳转到首页" |

**符合阶段 vs 不符合阶段**：
| 类型 | 判断标准 | 示例 |
|------|----------|------|
| 符合 | 请求属于当前阶段的正常产出 | 规划阶段讨论功能范围 |
| 不符合 | 请求属于其他阶段的产出 | 规划阶段要求写代码 |

### 三、系统能力

```
【规范层】
  └── CLAUDE.md + 产品PRD + 流程文档
      定义：流程阶段、AI行为准则、协作模式

【工具层】（迭代2+）
  └── CLI 脚本 / npm scripts
      辅助：状态查看、输入记录、快速操作

【进化层】（迭代3+）
  └── 元流程优化
      支持：规范版本管理、使用者偏好记录、自适应调整
```

### 四、核心流程

```
项目启动 → 迭代循环（规划 → 设计 → 实现 → 验证）
```

---

## 五、项目启动阶段产出

**产品级文档（项目启动阶段产出）**：

| 文档 | 目的 | 内容 |
|------|------|------|
| **产品PRD** | 定义产品是什么 | 愿景、用户、元原则、路线图 |
| **流程文档** | 定义如何协作 | 业务流程（High Level）、协作模式、模块职责划分 |

**创建时机**：
- 产品PRD定稿后，同步创建流程文档
- 流程文档定义 High Level 的业务流程和协作模式
- 后续迭代基于流程文档进行细化和修订

**为什么在项目启动阶段创建流程文档**：
1. 符合"文档即真理源"原则 - 产品级文档在产品级阶段产出
2. 先定义协作方式，再细化实现 - 指导后续迭代设计
3. 避免"实现驱动设计" - 确保各迭代设计符合整体协作视角

---

## 六、路线图

### 阶段划分

| 阶段 | 目标 | 状态 |
|------|------|------|
| **迭代1** | 核心流程可用 | → 当前 |
| **迭代2** | 工具化增强 (CLI/Scripts) | 待规划 |
| **迭代3** | 知识库与元流程优化 | 待规划 |

### 迭代1目标

让核心流程**手动可用**：
- 输入日志机制
- 灵光收集箱
- 流程上下文
- 分层状态

详见：[迭代1-PRD](./iterations/迭代1-PRD.md)

---

## 七、成功标准

### 迭代1成功标准

- [ ] 能用此流程完成一个完整迭代（自举验证）
- [ ] 关键输入记录率 > 80%（需求/决策/反馈/变更类输入被记录）
- [ ] 灵光不丢失，处理周期 < 1个迭代
- [ ] AI 阶段引导有效率 > 70%（不符合阶段的请求被识别并引导）
- [ ] 状态可读、可追溯（人类能通过 status.json 了解当前状态）

### 产品最终成功标准

- [ ] 超级个体能独立使用完成软件开发全流程
- [ ] 流程规范能随使用者显式配置进化
- [ ] 工具能辅助规范执行
- [ ] AI 行为一致性持续提升（通过实践反馈优化 CLAUDE.md）

---

*版本：v0.5*
*创建时间：2024-12-16*
*更新时间：2024-12-17*
*更新内容：v0.2 增加重要认知、AI判断规则；v0.3 增加人机职责分工、上下文加载策略、Pending Docs机制、影响分析局限性、YAGNI原则、模块文档可选；v0.4 简化迭代1状态管理为仅 state.json、AI主动索取上下文；v0.5 重新定义 Pending Docs 触发场景（实现倒逼设计、快速热修复）*
